
\chapter{TSATPY - TABLESAT PYTHON BASE STATION}
\label{chap:TSatPy}

TSatPy

This module is designed to run a variety of observer based controls with a rotating rigid body.

Notable characteristics of this implementation of a rotating body's attitude observer based controller are:

Adaptive Step Algorithms

All time dependent calculations vary their parameters at run-time dependent on the time since the last time it ran. For example, calculations based on integrals or derivatives reference the system clock to scale the results based on what the clock reports is the current time step.

Variable System Clock

The system clock is the official time keeper for the entire ADCS. Advantages to using a central clock instead of the computer time is that the speed of elapsed time can be modified at run-time during simulations to either compress the time to complete the simulation or slow down the simulation to inspect a certain event.

Quaternion Multiplicative Corrections

Quaternions that quantify a system's position contain 4 values that are commonly tracked and controlled separately. This produces a lot of errors since the 4 values are co-dependent and altering one modifies the rest as well. Breaking the values apart also creates a disconnect between the values and the physical position they help define. Use of the quaternion multiplicative correction technique maintains the integrity of the values and their relation to the physical position of the system. Usages of quaternions in most estimators and controllers require normalization of the state to a unit vector after each calculation. In this implementation, the only time normalization that should ever be required is to correct for floating point error accumulation.

Quaternion Scaling

Unlike body rates that can be linearly scaled, the 4 quaternion values are a sinusoidal value where multiple values can represent the same attitude (i.e. 0, 360 degrees). The common method of scaling by the raw values can have unexpected results. Due to the trig of small angle interacting with quaternions that represent small deviations in this manner introduces a little error, but the linear assumption creates larger errors as the angle increases. All quaternion scaling in this library is performed or the angle that the quaternion represents. With this method, we can maintain the linear scaling affect that is desired while maintaining the integrity of the quaternion representation.

Run-time interface

Through the use of a python twisted daemon process an restful API interface is available to query the state of the system in the middle of a run. This creates the ability to display meaningful representations of the system and increase insight into the system's dynamic behavior instead of relying on batch post processing.

Sample video

Concurrent Estimation/Control Algorithms

When running a comparative analysis between different types of estimators or different types of controllers, common methods are to re-run simulations for each variation and compare the results. The library allows for configurations such as providing the same measurement values to both a PID and SMO estimator to compare their performance.

Quaternion Decomposition

With spin-stabilized satellites the only part of the attitude quaternion that requires control is the one that quantifies the "wobble". Since the 4 values are co-dependent as mentioned above just modifying 2 of the values results in a corrupted position representation.

Modular Design

This library is designed to have interchangeable components with predefined and consistent interfaces and roles by allowing for the inclusion of additional estimation and control techniques. In the case of estimation, an Extended Kalman Filter (EKF) class can be added by creating a new class in Estimator.py that has contains the common properties ($\bs{\hat{x}}$, $\bs{x}_e$..) and common methods ($\bs{\hat{x}}$ = update($\bs{x}$)).

Portable Design

The portable design dictates that with the defined interfaces between modules, the observer based control methods have no knowledge of what is producing the sensor readings and what is accepting moment commands. This enforces consistency in the behavior of the system whether it's hooked up to an in-memory model of a satellite, TableSat 1A, or any future spin spin-stabilized platform. The only code change that may be required (Sensor.py and Actuator.py) is in applying the system to a new platform that contains new types of sensors and actuators.

Python

Since control systems professionals regularly work in a Numerical Simulation Software environment (like Matlab Simulink or Octave) and when it comes to implementation the logic is generally converted to a more standard language by software engineers there becomes a disconnect between the planning and implementation of a controller. By using a language like python, the code can be written in an expressive manner so that a control systems professional only needs a little programming experience to modify the code. It also keeps the controller in a language than could be reviewed for optimization by a software engineer and applied to the actual system without requiring a conversion to an entirely different system or language.


\section{Implementation of Attitude Modeling}
\label{sec:ImplementationofAttitudeModeling}


\subsection{Quaternion Notation}
\label{subsec:Implementation-QuaternionNotation}
Section \ref{subsubsec:QuaternionNotation}

As will be described more in Chapter \ref{chap:TSatPy}, the implementation in this thesis is done in an object oriented manner so it can handle either the scalar first or scalar last format.

\begin{singlespace}
  \begin{minted}[mathescape,linenos,numbersep=10pt,frame=lines,framesep=2mm]{python}
from TSatPy.State import Quaternion
q = Quaternion(vector=[1,2,3], scalar=4)
print(q)
q = Quaternion(scalar=0, vector=[1,2,3])
print(q)

# Prints Out
# <Quaternion [1 2 3], 4>
# <Quaternion [1 2 3], 0>
  \end{minted}
  \nocite{minted}
\end{singlespace}

\subsection{Rotational Quaternion}
\label{subsec:Implementation-RotationalQuaternion}
Section \ref{subsubsec:RotationalQuaternion}

Creating a rotational quaternion from the TSatPy (Chapter \ref{chap:TSatPy}) is done with

\begin{singlespace}
  \begin{minted}[mathescape,linenos,numbersep=10pt,frame=lines,framesep=2mm]{python}
from TSatPy.State import Quaternion

q = Quaternion(vector=[1,2,3], radians=4)
e, theta = q.to_rotation()

print(q)
print("Euler axis: <%g, %g, %g>" % (e[0,0], e[1,0], e[2,0]))
print("Rotation: %g radians" % theta)

# Prints Out
# <Quaternion [-0.24302 -0.48604 -0.72906], -0.416147>
# Euler axis: <-0.267261, -0.534522, -0.801784>
# Rotation: 4 radians
  \end{minted}
  \nocite{minted}
\end{singlespace}

\subsection{Quaternion Multiplication}
\label{subsec:Implementation-QuaternionMultiplication}

Section \ref{subsubsec:QuaternionMultiplication}

The example below shows how this incremental changes holds true with the TSatPy library.
\begin{singlespace}
  \begin{minted}[mathescape,linenos,numbersep=10pt,frame=lines,framesep=2mm]{python}
from TSatPy.State import Quaternion

a = Quaternion([1,2,3], radians=0.5)
b = Quaternion([1,2,3], radians=2)
print("a             = %s" % a)
print("a * a * a * a = %s" % (a * a * a * a))
print("b             = %s" % b)
# Prints Out
# a             = <Quaternion [-0.0661215 -0.132243 -0.198364], 0.968912>
# a * a * a * a = <Quaternion [-0.224893 -0.449785 -0.674678], 0.540302>
# b             = <Quaternion [-0.224893 -0.449785 -0.674678], 0.540302>
  \end{minted}
  \nocite{minted}
\end{singlespace}

Section \ref{subsubsec:QuaternionMultiplication} includes a small example of quaternion multiplication and the following snippet is the implementation of the quaternion multiplication which reads and is used similarly to how the quaternion algebra is written.

\begin{singlespace}
  \begin{minted}[mathescape,linenos,numbersep=10pt,frame=lines,framesep=2mm]{python}
class Quaternion(object):
    def __mul__(self, q):
        v = (self.x + np.eye(3) * self.scalar) * q.vector
        v += self.vector * q.scalar
        s = self.scalar * q.scalar - (self.vector.T * q.vector)[0, 0]
        return Quaternion(v, s)
  \end{minted}
  \nocite{minted}
\end{singlespace}

\subsection{Rotating a Point with Quaternions}
\label{subsec:Implementation-RotatingaPointwithQuaternions}

Section \ref{subsubsec:RotatingaPointwithQuaternions}

The equivalent TSatPy implementation of the point rotation equation (Equation \ref{eqn:RotationMatrix})

\begin{singlespace}
  \begin{minted}[mathescape,linenos,numbersep=10pt,frame=lines,framesep=2mm]{python}
from TSatPy.State import Quaternion
import numpy as np

A = np.mat([2, 4, -1]).T
q = Quaternion([0,0,1], radians=np.pi/2)

print(q.rmatrix * A)

# Prints out
# [[-4.]
#  [ 2.]
#  [-1.]]
  \end{minted}
  \nocite{minted}
\end{singlespace}

\subsection{Incremental Quaternion Rotations}
\label{subsec:Implementation-IncrementalQuaternionRotations}
Section \ref{subsubsec:IncrementalQuaternionRotations}

Using the TSatPy code, equation \ref{eqn:3rpmQuaternionEquation} can be implemented as

\begin{singlespace}
  \begin{minted}[mathescape,linenos,numbersep=10pt,frame=lines,framesep=2mm]{python}
from TSatPy.State import Quaternion
import time
import numpy as np

q_rps = Quaternion([0,0,1], radians=np.pi/10)
print('Quaternion spin rate (rad/sec)\n %s' % q_rps)

q_state = Quaternion([0,0,1], radians=np.pi/2)
print('Initial state of TableSat\n t=0: %s' % q_state)


print('Starting Open Loop State Tracking')
for k in range(1,11):
    time.sleep(1)
    q_state *= q_rps
    print(' t=%s: %s' % (k, q_state))

# Prints Out
# Quaternion spin rate (rad/sec)
#  <Quaternion [-0 -0 -0.156434], 0.987688>
# Initial state of TableSat
#  t=0: <Quaternion [-0 -0 -0.707107], 0.707107>
# Starting Open Loop State Tracking
#  t=1: <Quaternion [0 0 -0.809017], 0.587785>
#  t=2: <Quaternion [0 0 -0.891007], 0.45399>
#  t=3: <Quaternion [0 0 -0.951057], 0.309017>
#  t=4: <Quaternion [0 0 -0.987688], 0.156434>
#  t=5: <Quaternion [0 0 -1], 1.11022e-16>
#  t=6: <Quaternion [0 0 -0.987688], -0.156434>
#  t=7: <Quaternion [0 0 -0.951057], -0.309017>
#  t=8: <Quaternion [0 0 -0.891007], -0.45399>
#  t=9: <Quaternion [0 0 -0.809017], -0.587785>
#  t=10: <Quaternion [0 0 -0.707107], -0.707107>
  \end{minted}
  \nocite{minted}
\end{singlespace}

This implementation has both a big control theory and implementation issue.  The control theory concern is the estimate is running in an open loop without ever receiving corrections so the myriad of additional factors that affect a real system would quickly invalidate the accuracy of the estimate in this approach.  The implementation issue deals with the time step.  Even if TableSat/MMS spun perfectly at 3 rpm the state will not be updated exactly on each second.  A busy processor, numerical drift, and execution time will prevent the desired fixed step size of 1 sec.  In some of the earlier implementations of the base station controller discussed in Chapter \ref{chap:StandardTools} dropped UDP messages caused the control loop to execute on an inconsistent interval and prevent accurate state estimates.  Handling of the variability in timesteps will be covered Section \ref{sec:SatelliteDynamics}

\subsection{System Clock}
\label{subsec:Implementation-SystemClock}

Section \ref{subsec:SystemClock}

TSatPy implements this concept through the Metronome class.  An instance of this class serves as the reference frame for all rate calculations.  During the simulation, the clock is able to slow and quicken based on the set speed.

\begin{singlespace}
  \begin{minted}[mathescape,linenos,numbersep=10pt,frame=lines,framesep=2mm]{python}
from TSatPy.Clock import Metronome
import time

c = Metronome()
print("Start Time: system=%s, real=%s" % (c, time.time()))
time.sleep(2)
print("Lock step:  system=%s, real=%s" % (c, time.time()))
c.set_speed(0.1)
time.sleep(30)
print("Slow-mo:    system=%s, real=%s" % (c, time.time()))
c.set_speed(100)
time.sleep(4)
print("FFW:        system=%s, real=%s" % (c, time.time()))

# Prints Out
# Start Time: system=7.86781e-06s, real=1396147884.5
# Lock step:  system=2.00162s, real=1396147886.5
# Slow-mo:    system=5.00364s, real=1396147916.52
# FFW:        system=405.292s, real=1396147920.52
  \end{minted}
  \nocite{minted}
\end{singlespace}

\subsection{Body Rate Quaternion Propagation}
\label{subsec:Implementation-BodyRateQuaternionPropagation}
Section \ref{subsec:BodyRateQuaternionPropagation}

\begin{singlespace}
  \begin{minted}[mathescape,linenos,numbersep=10pt,frame=lines,framesep=2mm]{python}
from TSatPy.Clock import Metronome
from TSatPy import State
import time

clock = Metronome()

M = [0, 0, 0.5]
w = State.BodyRate([0, 0, 0])
eme = State.EulerMomentEquations([[10, 0, 0], [0, 10, 0], [0, 0, 10]], w, clock)

for k in range(5):
    w = eme.propagate(M)
    print(w)
    time.sleep(1)

# Prints Out
# <BodyRate [0 0 0]>
# <BodyRate [0 0 0.0500562]>
# <BodyRate [0 0 0.10012]>
# <BodyRate [0 0 0.150189]>
# <BodyRate [0 0 0.200252]>
  \end{minted}
\nocite{minted}
\end{singlespace}

The quaternion propagation operates in the same way as the body rate propagation, and Equation \ref{eqn:DiscreteQuaternionPropagation} is implemented in the QuaternionDynamics class.  The sample simulation below describes a basic quaternion propagation where the TableSat/MMS model is tracking a 0.1 rad/sec rotation about the $+z$ axis.  The system clock initially tracks with the real time, so about a second of real elapsed time equates to the equivalent system time change.  After each update the angle increases by about 0.1 rad.  After a four second transient response period the system clock is sped up by a factor of five (line 19).  After that each step simulates a 0.5 rad increase from when the clock speed changed.

\begin{singlespace}
  \begin{minted}[mathescape,linenos,numbersep=10pt,frame=lines,framesep=2mm]{python}

from TSatPy.Clock import Metronome
from TSatPy import State
import time

c = Metronome()
print("Setting spin rate of 0.1 rad/sec about +z")
w = State.BodyRate([0, 0, 0.1])
q_ic = State.Identity()

qd = State.QuaternionDynamics(q_ic, c)

for _ in range(4):
    time.sleep(1)
    e, theta = qd.propagate(w).to_rotation()
    print(" Rotation Angle: %s" % theta)

print("Initial transient response inspection complete.")
print("Speed up 5x for steady state response.")
c.set_speed(5)

for _ in range(4):
    time.sleep(1)
    e, theta = qd.propagate(w).to_rotation()
    print(" Rotation Angle: %s" % theta)

# Prints Out
# Setting spin rate of 0.1 rad/sec about +z
#  Rotation Angle: 0.0
#  Rotation Angle: 0.100147199631
#  Rotation Angle: 0.203001904488
#  Rotation Angle: 0.303643703461
# Initial transient response inspection complete.
# Speed up 5x for steady state response.
#  Rotation Angle: 0.804805707932
#  Rotation Angle: 1.30787069798
#  Rotation Angle: 1.81127579212
#  Rotation Angle: 2.3147197485
  \end{minted}
  \nocite{minted}
\end{singlespace}

\TODO{How do we incorporate the videos demonstrating the plant state propagation with input moments? Unforced propagation https://vimeo.com/68018120. Applied moments https://vimeo.com/42960673 }





\section{Modules}
\label{sec:Modules}

Below is an outline of the separate modules contained in the TSatPy library and their associated roles.

\subsection{Actuators}
\label{subsec:actuators}

This module defines the output of the controller. The actuator instance on initialization, is supplied with the physical arrangement of the actuators and when activated, what moments they are able to produce. During run-time the actuators follow the following logic:

    Accept a $\Re^3$ moment from the controller
    Determine the actual moment that is possible from the physical arrangement
    Convert the desired moments to voltage settings
    Submit the actuator voltage settings to
        the Comm for transmission to the experimental setup or
        the plant for theoretical simulations
    Report the actual applied moments back to the estimator for state propagation

\subsection{ADCS}
\label{subsec:ADCS}


This module is the parent container for all the observer based controls, and comm instances. The instance of the ADCS should accept a json config that can be easily stored and define the setup of the model including type and number of estimators.

    input: config json
    output: ADCS model

\subsection{Clock}
\label{subsec:Clock}


This module governs the system clock of the ADCS system and should be referenced by any logic in the observer or controller that is time dependent such as calculations reliant on integrals or derivatives of parameters. The metronome class by default track seconds since the initialization of the clock, but when running simulations can have it's speed dynamically altered to either run faster for long term simulations or run slower to get better inspection of an event.

    input: None
    output: elapsed time

\subsection{Comm}
\label{subsec:Comm}


This module handles the interface between the the control system and either the physical system or the theoretical model. With the physical system, a UDP socket is opened and either listens for packets transmitted from the sensors or submits voltage packets to set actuator voltages. When running in simulations, the module submits and receives the voltage messages to an in-memory model of the system that contains the system dynamics and can return mocked sensor voltages based on the behavior.

From Controller to Satellite

    input: Voltage setting determined by the actuator
    output: UDP packet to the system or in-memory model

From Satellite to Controller

    input: Sensor voltages from the system or in-memory model
    output: Sensor data to submit to sensor class for conversion to a state

\subsection{Controller}
\label{subsec:Controller}


This module contains the algorithms that take what we have estimated the system to be doing, compare it to what we want it to do, and determine what moments need to be applied to make the system behave as desired.

The master control instance governs the interface between the incoming estimator state and the outgoing actuator moments. The master controller can run multiple control algorithms simultaneously which can be individually tuned to different types of system behaviors like one that can handle large errors and one for the soft corrections at steady state.

    input: configuration of what types of control algorithms should be used and the parameters required to set them up
    output: a desired moment based on the active control algorithm's calculations

\subsection{Estimator}
\label{subsec:Estimator}


This module contains the algorithm that take the measured state from the sensor model which jumps around a lot because of the noise in the originating signal and attempts to eliminate the noise and create an accurate representation of the true state of the system.

    input: measured state ($\bs{x}$)
    output: estimated true state ($\bs{\hat{x}}$)

\subsection{Sensor}
\label{subsec:Sensor}


This module receives raw voltage measurements from either a simulated truth model of the system or from the Comm module polling sensor voltage data off the experimental system.

Each class represents a different sensor type (course sun sensor, magnetometer, gyroscope, ...) and contain the logic to convert sensor readings from that sensor into a state representation x with quaternion and body rates.

    input: voltages (V)
    output: measured state (x)

\subsection{Service}
\label{subsec:Service}


Based off a twisted daemon. This module contains the logic setting up the daemon and establishing the socket interfaces with the physical model.

    input: run configuration
    output: twisted daemon config

\subsection{StateOperator}
\label{subsec:StateOperator}

This module contains classes that are designed to modify instances from the State module or convert between them. For example a quaternion can represent the difference between two attitudes. In an estimator or controller we don't want to always just jump all the way to the new state because of noise in the readings. With a QuaternionGain we can scale back the difference and adjust our attitude based on a fraction of the difference which over time will reduce the overall error between the states. In the case of the controller, the state instance needs to be converted to a Moment by a StateToMoment class.
Class   What it does
BodyRateGain  Scale a BodyRate instance
QuaternionGain  Scale a Quaternion instance
StateGain   Scale the State instance (Wrapper for QuaternionGain, BodyRateGain)
QuaternionSaturation  Saturate a Quaternion
BodyRateSaturation  Saturate a BodyRate
StateSaturation   Saturate a State (Wrapper for QuaternionSaturation, BodyRateSaturation)
BodyRateToMoment  Convert a BodyRate to a Moment
QuaternionToMoment  Convert a Quaternion to a Moment
StateToMoment   Convert a State to a Moment (Wrapper for QuaternionToMoment, BodyRateToMoment)

    input: An instance from the State module
    output: A modified instance or the conversion to a new State instance

\subsection{State}
\label{subsec:State}

This module contains classes that are used to quantify the state of the system.
State   Class
Attitude  Quaternion
Spin rates  BodyRate
Difference in attitudes   QuaternionError
How body rates change the attitude  QuaternionDynamics
How moments change the body rates   EulerMomentEquations
Position and velocity   State - Couples the position (Quaternion) with velocity (BodyRate)
Differences in position and velocity  StateError
In-memory model of the satellite  Plant
Applied torques   Moment

